{
    "notes": [
      {
        "title": "ways to deploy the application on AWS ?",
        "description":[{
          "summary": "1. Amazon EC2 (Elastic Compute Cloud)",
          "code": "Use Case: Ideal for applications that require full control over the underlying infrastructure and operating system. \nAdvantages:\n  Provides virtual servers (EC2 instances) that can be customized with different instance types, operating systems, and configurations. \n  Suitable for legacy applications or those with specific software dependencies. \n  Offers flexibility in managing infrastructure resources directly."
        },
        {
          "summary": "2. AWS Elastic Beanstalk",
          "code": "Use Case: Suitable for developers who want to deploy applications without managing underlying infrastructure details.\nAdvantages:\n  Automatically handles deployment, load balancing, scaling, and monitoring of applications. \n  Supports various programming languages and platforms (Java, .NET, PHP, Node.js, Python, Ruby, Docker). \n  Integrates seamlessly with other AWS services like RDS, S3, and CloudWatch."
        },{
          "summary": "3. AWS Lambda",
          "code": "Use Case: Ideal for event-driven applications or microservices architectures.\nAdvantages:\n  Serverless compute service where you only pay for the compute time consumed.\n  Automatically scales based on incoming traffic. \n  Supports multiple programming languages (Node.js, Python, Java, Ruby, Go, .NET Core)."
        },{
          "summary": "4. AWS ECS (Elastic Container Service) or EKS (Elastic Kubernetes Service)",
          "code": "Use Case: Suitable for containerized applications managed with Docker or Kubernetes.\nAdvantages:\n  ECS: Fully managed container orchestration service for Docker containers.\n  EKS: Managed Kubernetes service that simplifies deployment, management, and scaling of Kubernetes clusters. \n  Allows flexibility in managing containerized applications with capabilities for auto-scaling, load balancing, and integration with other AWS services."
        },{
          "summary": "5. AWS Fargate",
          "code": "Use Case: Ideal for running containers without managing underlying infrastructure.\nAdvantages:\n  Serverless compute engine for containers that works with both ECS and EKS.\n  Automatically scales based on workload demands. \n  Eliminates the need to provision and manage servers or clusters."
        },{
          "summary": "6. AWS Serverless Application Model (SAM)",
          "code": "Use Case: Suitable for building and deploying serverless applications using AWS Lambda and API Gateway.\nAdvantages:\n  Simplifies deployment of serverless applications with a framework for defining serverless resources and managing dependencies.\n  Integrates seamlessly with other AWS services."
        }]
      },
      {
        "title": "Deploying AI/ML applications on AWS ?",
        "description":[{
          "summary": "1. Amazon SageMaker",
          "code": "Use Case: Ideal for building, training, and deploying machine learning models at scale.\nAdvantages:\n  Managed Service: Simplifies the entire ML lifecycle from data labeling and model training to deployment and monitoring. \n  Pre-built Algorithms: Includes built-in algorithms for common ML tasks, reducing development time. \n  Automatic Model Tuning: Optimizes model performance with automatic hyperparameter tuning.\n  Integration: Easily integrates with other AWS services like S3, IAM, and CloudWatch for data management, security, and monitoring."
        },
        {
          "summary": "2. Amazon EC2 Instances with GPU Support",
          "code": "Suitable for training deep learning models that require GPU acceleration.\nAdvantages:\n  Customizability: Choose instance types with GPU support (e.g., P3, P4) tailored to specific computational requirements. \n  Performance: Provides high computational power necessary for intensive tasks like image or video processing, natural language processing (NLP), and computer vision. \n  Flexibility: Allows fine-grained control over software stack and configurations."
        },{
          "summary": "3. AWS Lambda for Serverless Inference",
          "code": "Use Case: Deploy pre-trained models for inference without managing servers.\nAdvantages:\n  Cost-effective: Pay only for the compute time consumed during inference.\n  Scalability: Scales automatically based on incoming requests. \n  Integration: Integrates seamlessly with AWS API Gateway for building APIs around ML models."
        },{
          "summary": "4. AWS IoT Greengrass for Edge AI",
          "code": "Use Case: Deploy ML models to edge devices (IoT devices) for local inference and decision-making.\nAdvantages:\n  Edge Computing: Process data locally on IoT devices to reduce latency and dependence on cloud connectivity.\n  Offline Operation: Operate AI/ML models even when devices are offline or have limited connectivity. \n  Security: Implements AWS security features locally at the edge."
        },{
          "summary": "5. Amazon Elastic Kubernetes Service (EKS) or Elastic Container Service (ECS) for Containerized Workloads",
          "code": "Run containerized AI/ML applications using Docker containers.\nAdvantages:\n  Orchestration: Manage and orchestrate containers at scale with Kubernetes (EKS) or ECS.\n  Flexibility: Choose between managing Kubernetes clusters (EKS) or using AWS-managed container orchestration (ECS). \n  Integration: Integrates with other AWS services and allows for custom configurations based on workload requirements."
        }]
      },
      
      {
        "title": "Amazon SageMaker",
        "description":[{
          "summary": "Ideal for building, training, and deploying machine learning models at scale.",
          "code": ""
        },
        {
          "summary": "Importance of Directives : Code Reusability, Encapsulation, Separation of Concerns",
          "code": ""
        },
        {
          "summary": "Challenges Without Directives: Code Duplication, DOM Manipulation in Controllers, Limited Reusability",
          "code": "<button id='tooltipBtn' (mouseover)='showTooltip = true' (mouseout)='showTooltip = false'> \n Hover me for tooltip\n</button>\n<div *ngIf='showTooltip' class='tooltip'>This is a tooltip</div> "
        },
        {
          "summary": "Example using directive",
          "code": "<button id='tooltipBtn' appTooltip> \n Hover me for tooltip \n</button>"
        }],
        "summary": "Directives in Angular are essential because they allow you to extend HTML with custom behavior and create reusable components. They play a crucial role in enhancing code readability, maintainability, and reusability by encapsulating complex DOM manipulations and behavior into a single component.",
        "code": "const name = 'World';\nconsole.log(`Hello, ${name}!`);"
      },
      {
        "title": "Lazy Loading",
        "summary": "ng g module modulename --routing",
        "code": "const name = 'World';\nconsole.log(`Hello, ${name}!`);"
      }
    ]
  }